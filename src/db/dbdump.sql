-- Adminer 4.8.1 MySQL 8.0.31 dump

SET NAMES utf8;
SET time_zone = '+00:00';
SET foreign_key_checks = 0;
SET sql_mode = 'NO_AUTO_VALUE_ON_ZERO';

SET NAMES utf8mb4;

DROP TABLE IF EXISTS `step_option`;
CREATE TABLE `step_option` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `uses_vars` tinyint(1) DEFAULT NULL,
  `help` text,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

INSERT INTO `step_option` (`id`, `name`, `uses_vars`, `help`) VALUES
(1,	'FROM',	1,	'```dockerfile\r\nFROM [--platform=<platform>] <image> [AS <name>]\r\n\r\n```\r\n\r\nOr\r\n\r\n```dockerfile\r\nFROM [--platform=<platform>] <image>[:<tag>] [AS <name>]\r\n\r\n```\r\n\r\nOr\r\n\r\n```dockerfile\r\nFROM [--platform=<platform>] <image>[@<digest>] [AS <name>]\r\n\r\n```\r\n\r\nThe `FROM` instruction initializes a new build stage and sets the [*Base Image*](https://docs.docker.com/glossary/#base-image) for subsequent instructions. As such, a valid `Dockerfile` must start with a `FROM` instruction. The image can be any valid image â€“ it is especially easy to start by **pulling an image** from the [*Public Repositories*](https://docs.docker.com/docker-hub/repos/).\r\n\r\n*   `ARG` is the only instruction that may precede `FROM` in the `Dockerfile`. See [Understand how ARG and FROM interact](https://docs.docker.com/engine/reference/builder/#understand-how-arg-and-from-interact).\r\n*   `FROM` can appear multiple times within a single `Dockerfile` to create multiple images or use one build stage as a dependency for another. Simply make a note of the last image ID output by the commit before each new `FROM` instruction. Each `FROM` instruction clears any state created by previous instructions.\r\n*   Optionally a name can be given to a new build stage by adding `AS name` to the `FROM` instruction. The name can be used in subsequent `FROM` and `COPY --from=<name>` instructions to refer to the image built in this stage.\r\n*   The `tag` or `digest` values are optional. If you omit either of them, the builder assumes a `latest` tag by default. The builder returns an error if it cannot find the `tag` value.\r\n\r\nThe optional `--platform` flag can be used to specify the platform of the image in case `FROM` references a multi-platform image. For example, `linux/amd64`, `linux/arm64`, or `windows/amd64`. By default, the target platform of the build request is used. Global build arguments can be used in the value of this flag, for example [automatic platform ARGs](https://docs.docker.com/engine/reference/builder/#automatic-platform-args-in-the-global-scope) allow you to force a stage to native build platform (`--platform=$BUILDPLATFORM`), and use it to cross-compile to the target platform inside the stage.\r\n\r\n### Understand how ARG and FROM interact[ðŸ”—](https://docs.docker.com/engine/reference/builder/#understand-how-arg-and-from-interact)\r\n\r\n`FROM` instructions support variables that are declared by any `ARG` instructions that occur before the first `FROM`.\r\n\r\n```dockerfile\r\nARG  CODE_VERSION=latest\r\nFROM base:${CODE_VERSION}\r\nCMD  /code/run-app\r\n\r\nFROM extras:${CODE_VERSION}\r\nCMD  /code/run-extras\r\n\r\n```\r\n\r\nAn `ARG` declared before a `FROM` is outside of a build stage, so it canâ€™t be used in any instruction after a `FROM`. To use the default value of an `ARG` declared before the first `FROM` use an `ARG` instruction without a value inside of a build stage:\r\n\r\n```dockerfile\r\nARG VERSION=latest\r\nFROM busybox:$VERSION\r\nARG VERSION\r\nRUN echo $VERSION > image_version\r\n```'),
(2,	'RUN',	NULL,	'RUN has 2 forms:\r\n\r\n*   `RUN <command>` (*shell* form, the command is run in a shell, which by default is `/bin/sh -c` on Linux or `cmd /S /C` on Windows)\r\n*   `RUN [\"executable\", \"param1\", \"param2\"]` (*exec* form)\r\n\r\nThe `RUN` instruction will execute any commands in a new layer on top of the current image and commit the results. The resulting committed image will be used for the next step in the `Dockerfile`.\r\n\r\nLayering `RUN` instructions and generating commits conforms to the core concepts of Docker where commits are cheap and containers can be created from any point in an imageâ€™s history, much like source control.\r\n\r\nThe *exec* form makes it possible to avoid shell string munging, and to `RUN` commands using a base image that does not contain the specified shell executable.\r\n\r\nThe default shell for the *shell* form can be changed using the `SHELL` command.\r\n\r\nIn the *shell* form you can use a `\\` (backslash) to continue a single RUN instruction onto the next line. For example, consider these two lines:\r\n\r\n```dockerfile\r\nRUN /bin/bash -c \'source $HOME/.bashrc; \\\r\necho $HOME\'\r\n\r\n```\r\n\r\nTogether they are equivalent to this single line:\r\n\r\n```dockerfile\r\nRUN /bin/bash -c \'source $HOME/.bashrc; echo $HOME\'\r\n\r\n```\r\n\r\nTo use a different shell, other than â€˜/bin/shâ€™, use the *exec* form passing in the desired shell. For example:\r\n\r\n```dockerfile\r\nRUN [\"/bin/bash\", \"-c\", \"echo hello\"]\r\n\r\n```\r\n\r\n> **Note**\r\n>\r\n> The *exec* form is parsed as a JSON array, which means that you must use double-quotes (â€œ) around words not single-quotes (â€˜).\r\n\r\nUnlike the *shell* form, the *exec* form does not invoke a command shell. This means that normal shell processing does not happen. For example, `RUN [ \"echo\", \"$HOME\" ]` will not do variable substitution on `$HOME`. If you want shell processing then either use the *shell* form or execute a shell directly, for example: `RUN [ \"sh\", \"-c\", \"echo $HOME\" ]`. When using the exec form and executing a shell directly, as in the case for the shell form, it is the shell that is doing the environment variable expansion, not docker.\r\n\r\n> **Note**\r\n>\r\n> In the *JSON* form, it is necessary to escape backslashes. This is particularly relevant on Windows where the backslash is the path separator. The following line would otherwise be treated as *shell* form due to not being valid JSON, and fail in an unexpected way:\r\n>\r\n> ```dockerfile\r\n> RUN [\"c:\\windows\\system32\\tasklist.exe\"]\r\n>\r\n> ```\r\n>\r\n> The correct syntax for this example is:\r\n>\r\n> ```dockerfile\r\n> RUN [\"c:\\\\windows\\\\system32\\\\tasklist.exe\"]\r\n>\r\n> ```\r\n\r\nThe cache for `RUN` instructions isnâ€™t invalidated automatically during the next build. The cache for an instruction like `RUN apt-get dist-upgrade -y` will be reused during the next build. The cache for `RUN` instructions can be invalidated by using the `--no-cache` flag, for example `docker build --no-cache`.\r\n\r\nSee the [`Dockerfile` Best Practices guide](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/) for more information.\r\n\r\nThe cache for `RUN` instructions can be invalidated by [`ADD`](https://docs.docker.com/engine/reference/builder/#add) and [`COPY`](https://docs.docker.com/engine/reference/builder/#copy) instructions.\r\n\r\n### Known issues (RUN)[ðŸ”—](https://docs.docker.com/engine/reference/builder/#known-issues-run)\r\n\r\n*   [Issue 783](https://github.com/docker/docker/issues/783) is about file permissions problems that can occur when using the AUFS file system. You might notice it during an attempt to `rm` a file, for example.\r\n\r\n    For systems that have recent aufs version (i.e., `dirperm1` mount option can be set), docker will attempt to fix the issue automatically by mounting the layers with `dirperm1` option. More details on `dirperm1` option can be found at [`aufs` man page](https://github.com/sfjro/aufs3-linux/tree/aufs3.18/Documentation/filesystems/aufs)\r\n\r\n    If your system doesnâ€™t have support for `dirperm1`, the issue describes a workaround.');

-- 2022-11-04 03:32:04